# PeelPack 需求分析与产品定义

## 核心命题

PeelPack 要解决的问题非常清晰：从"单张好看的 AI 图"到"整套可用的贴纸"之间，存在一条深深的鸿沟。这条鸿沟不是技术能力的缺失，而是一致性、速度和可用性的三重挑战。当前的 AI 生图工具大多停留在"生成单张精美作品"的层面，但贴纸的本质是成套的、有记忆点的、能立刻投入使用的视觉语言系统。PeelPack 的野心就是把这个鸿沟填平，让创造从"炫技"回归到"可用"。

## 输入的三种自由度

PeelPack 支持三种输入形式：纯文字描述、纯图片上传、以及文字与图片的混合。这三种形式对应了用户创作的不同场景和心理状态。纯文字描述是"我想要一个..."的创造模式，用户脑海中有角色想象但缺乏视觉参考；纯图片上传是"把这个变成..."的转化模式，用户手握具体素材想要风格化处理；混合模式则是"基于这张图，再加上..."的精细控制，用户既有视觉基础又有特定的改造意图。

这种灵活性不会带来复杂度的爆炸，因为无论哪种输入，最终都会进入统一的生成管线。文字是 Prompt，图片是 Reference，混合则是 Prompt + Reference，本质上是同一个生成逻辑的不同参数配置。关键在于 UI 层面不能让用户感到困惑——三种模式应该有清晰的入口和预期设定，让用户在选择的瞬间就明白自己会得到什么。

## 双模块架构：生成与编辑

PeelPack 的核心能力由两个模块支撑：gen 模块负责从零到一的生成（文字或图片作为输入，输出一套贴纸），edit 模块负责对已有图片的风格转换（图片作为输入，输出风格化后的图片）。这两个模块在技术层面可能共享底层能力，但在产品层面需要分离——gen 是创造新角色，edit 是改造现有素材。

风格选择发生在生成之前，通过 UI 按钮的形式呈现。每个风格按钮背后对应一段精心设计的 Prompt 预设，用户点击"日系动漫"按钮时，实际上是在向生成模型传递"anime style, soft colors, clean lines..."这样的指令。这种设计的妙处在于：对于大多数用户，点击按钮就足够了，简单快速；对于想要深度控制的用户，Prompt 输入框始终可见可编辑，他们可以在预设基础上调整，也可以完全自己书写。

这种"预设为主、自定义为辅"的策略平衡了易用性和灵活性。预设风格是策划团队精心调试的结果，保证了品质下限和审美一致性；自定义 Prompt 则是留给创作者的自由空间，让 PeelPack 不会因为"只能这样"而失去探索的乐趣。

## 九宫格加七个意外

每套贴纸包含十六张图片：九张核心表情形成九宫格，覆盖基本情绪光谱（开心、难过、生气、惊讶、思考、害羞、得意、疲惫、爱心），七张随机生成的意外表情作为惊喜补充。这个配置来自对贴纸使用场景的理解：九宫格是刚需，确保用户在常见对话情境中总能找到合适的表情；七个意外是调料，让每套贴纸都有独特性和可玩性。

九宫格的情绪类型是固定的，但具体表现会因角色和风格而异——同样是"开心"，猫耳少女的开心和赛博朋克机器人的开心视觉呈现完全不同。七个意外则完全随机生成，可能是特定的动作（比心、敬礼、吃东西）、特定的场景（下雨、看书、睡觉），或者完全意料之外的创意组合。这种设计让用户既有可预期的稳定性，又有不可预期的惊喜感。

失败处理机制也围绕这个结构展开：如果某张表情生成失败，系统不会停止整个流程，而是继续生成其余部分，并在失败位置标记"重新生成"入口。用户最终拿到的可能是十五张成功加一张待重试，而不是因为一张失败导致整个流程中断。这种容错设计确保了"90秒内总能得到可用结果"的承诺。

## 一致性由模型保证

"统一风格、统一色调、统一记忆点"是 PeelPack 的核心承诺，但这个承诺的实现不在产品层面的复杂逻辑，而在底层生成模型的能力。现代 AI 生图模型已经具备了强大的角色一致性能力，无论是通过 LoRA 微调、IP-Adapter 技术，还是更先进的多图一致性方案，都能确保同一个角色在不同表情、不同姿态下保持视觉特征的稳定。

产品层面需要做的是：为模型提供足够清晰的角色定义（通过 Prompt 或参考图），并在生成多张图片时保持这个定义的一致性。无论用户选择的是预设风格还是自定义 Prompt，只要角色描述稳定，模型就能输出"一眼认出是同一个角色"的贴纸集。这种一致性不是像工业流水线那样的绝对统一——背景可以变化、角度可以不同、姿态可以多样，但核心特征（发色、服装、配饰、整体气质）会被模型自动保持。

这意味着 PeelPack 不需要自己实现复杂的特征提取和风格迁移算法，而是充分信任和利用底层模型的能力。产品的价值在于把这个能力包装成简单易用的交互流程，让用户不需要理解技术细节就能获得高质量的结果。

## 内容边界交给守门人

内容审核是一个复杂且敏感的问题，但 PeelPack 选择了最务实的方案：完全依赖底层生图模型的 API 提供方。主流的 AI 生图服务（无论是商业 API 还是开源模型的托管平台）都已经内置了内容安全机制，会自动拦截涉及名人、商标、暴力、色情等不适内容的生成请求。

PeelPack 不在产品层面做二次审核，而是直接透传 API 返回的错误信息。如果生成请求因为内容问题被拒绝，用户会看到来自模型方的说明（可能经过产品化的文案润色），并被引导修改输入。这种设计的好处是：避免了维护自己的审核规则库（这是一个持续投入且容易出错的工作），同时也把法律责任和技术责任转移到了专业的模型提供方。

唯一需要产品层面处理的是用户体验：当审核拦截发生时，不是冷冰冰的报错，而是友好的提示和建议。比如"您的描述可能包含受保护的内容，试试用更通用的词语描述吧"，而不是"Error: content_policy_violation"。

## 轻量级存储方案

历史作品的存储采用自建的轻量级 OSS 服务，本质上是一个映射到本地文件系统 data/ 目录的对象存储层。这个方案的核心思想是：用最简单的方式实现必要的功能，避免过早引入云服务的复杂度和成本。

每次用户生成一套贴纸，系统会在 data/ 目录下创建一个以时间戳或 UUID 命名的文件夹，里面包含这套贴纸的所有图片以及一个元数据文件（记录输入参数、生成时间、风格选择等信息）。用户可以通过产品界面浏览自己的历史作品，选择重新下载、继续编辑或者删除。这些操作本质上就是对 data/ 目录下文件的读写操作，包了一层产品化的 UI。

这种方案在项目早期足够用，因为用户量不大、数据量可控，本地文件系统的性能完全够用。等到真正需要扩展时（比如用户希望跨设备访问、需要 CDN 加速），再迁移到真正的云存储服务也不晚。重要的是现在不要为未来的需求过度设计——YAGNI 原则在这里完美适用。

## 导出即标准 ZIP

导出格式采用最通用的方案：ZIP 压缩包，内含所有 PNG 图片。不做平台特定的格式适配（比如微信表情包的 .zip 结构或 Telegram 的 .tgs 格式），而是提供最标准的输出，让用户自己根据需要进一步处理。

这个决策的逻辑在于：与其花精力适配各个聊天平台的特定格式（这些格式还可能随平台更新而变化），不如把精力放在生成质量本身。PNG 是最广泛支持的图片格式，ZIP 是最通用的压缩格式，任何平台都能处理。如果未来发现大量用户有特定平台的导出需求，再针对性地添加功能也不迟。

产品界面可以提供简单的导入指南，告诉用户如何把 ZIP 里的图片添加到微信、Telegram、Discord 等常用平台。这种"授人以渔"的方式比"授人以鱼"更符合 PeelPack 的产品哲学——我们提供原料和工具，用户决定如何使用。

## 小贴纸机的相框隐喻

"PeelPack 是一台小贴纸机"这个定位不只是文案上的比喻，而是产品功能的具象化。在图片 API 调用完成后，PeelPack 会给每张生成的图片套上一层预设的相框或边框效果，让它们在视觉上更接近"贴纸"而不是"插画"。

这个相框可以是简单的白色描边（像真实的贴纸撕下来的效果），可以是圆角矩形的底色衬托，也可以是更有设计感的装饰性边框。关键在于：这一层后处理让生成的图片获得了"贴纸感"——不是平面的图片，而是仿佛可以贴在聊天框里、笔记本上、冰箱门上的小物件。

这个设计也呼应了产品名称"PeelPack"——Peel 是剥离、撕下的意思，Pack 是打包、成套。相框效果让每张图片看起来像是可以从背景中"撕下来"的独立贴纸，而不是融入背景的插画。这种视觉语言上的统一强化了产品的定位：我们不做万能的 AI 绘画工具，只做专注的贴纸生成器。

## 产品边界的克制

PeelPack 不支持生成壁纸、海报、头像、多角色场景，也不提供复杂的图片编辑功能。这些"不做什么"的决定和"做什么"一样重要。每个被拒绝的功能都是在保护产品的核心价值——简单、快速、专注。

当用户试图用 PeelPack 做超出贴纸生成的事情时，产品应该温和但明确地引导他们回到正轨。比如用户输入"生成一张 4K 壁纸"，系统可以回应"PeelPack 专注于贴纸生成，如果你想要壁纸，可以试试 [其他工具推荐]"。这种克制不是功能的缺失，而是定位的清晰——我们做一件事，但把这一件事做到极致。

相框的存在本身就是一种边界的物理化表达：贴纸有边界、有形状、有明确的视觉范围，它不是无限延展的画布，而是有限且完整的小作品。这种边界感让 PeelPack 在功能上保持克制，在体验上保持聚焦。

## 从愿景到执行

基于以上的需求明确，PeelPack 的产品形态已经相当清晰：一个支持三种输入模式的界面，一组精心设计的风格预设按钮（以及一个自定义 Prompt 输入框），一个双模块的生成架构（gen + edit），一套固定的输出结构（9+7 贴纸配置），一个简单的本地存储方案（data/ 目录 + 轻量 OSS），以及一个标准化的导出流程（ZIP 打包）。

技术栈的选择可以在这个需求框架下灵活决定，但产品逻辑已经足够稳定。接下来的工作是把这些需求翻译成具体的功能模块、交互流程和技术方案，但核心的产品哲学不会变：朴素、快速、可用，专注于把"生成一套可用的贴纸"这件事做到极致。
